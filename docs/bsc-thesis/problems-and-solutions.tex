%
%   Copyright 2013 Katarzyna Szawan <kat.szwn@gmail.com>
%       and Micha≈Ç Rus <m@michalrus.com>
%
%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%
%       http://www.apache.org/licenses/LICENSE-2.0
%
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.
%

\section{Encountered problems and their solutions}
\label{sec:impl-problems}

\subsection{Encapsulation of bidirectional message passing over request-response style HTTP protocol}
\label{subsec:problem-longpolling}

Most web browsers have a limit for concurrently open connections to the same server set to a value close to 2. This means it would be best to encapsulate message passing in \emph{one} constantly open connection, to leave the other free to be used in any way needed (e.g. to download some media resources).

This is not much of an issue when Android is concerned, because as many connections can be opened as we need. However, as it is really easy to add other front-ends (web application), it is wise to implement the REST actors (\cref{subsection:akka-actors}) and the client to be able to operate sequentially on one connection only.

What has to be done on the client-side is to disconnect/destroy the connection with a request og \inlinecode{GET /poll/since/\$TIME} and only then send \inlinecode{POST /update}. This is almost equally straightforward with Spray: we have to overload \inlinecode{onConnectionClosed} method of \inlinecode{HttpServiceBase} and in its new, overloaded body stop an appriopriate Poller actor.

The final choice whether to use one or two connections is left to the client: to our Akka backend both of these cases are of completely no difference.

\subsection{No removing of tabs in Android's TabHost}
\label{subsec:problem-tabhost}

Strange as it may seem, the system-provided TabHost component does not allow a removal of tabs on the same level of abstraction as it allows adding them. To remove a tab, one has to find the tab's \emph{raw} view and remove the view from its parent, the TabHost. On the other hand, to add a new tab, one has to create a TabSpec object and add this object to the TabHost. Quite a discrepancy.

It has been decided to keep track of all created TabSpecs manually and at removal request, remove \emph{all} of added tabs, remove a corresponding TabSpec from our collection and then recreate all tabs from this just reduced collection.

\subsection{No bidirectional scroll view in Android standard components}
\label{subsec:problem-scrollview}
In our application we implemented multi-directional scrolling in a class \inlinecode{Horizontal ScrollViewWithPropagation} which extends \inlinecode{HorizontalScrollView}. Inside, there is a \inlinecode{ScrollView} variable. If this inner \inlinecode{ScrollView} is set, we obtain o copy of \inlinecode{MotionEvent}, then we transform this copy in X axis and dispatch to the inner \inlinecode{ScrollView}. In the end, the original \inlinecode{MotionEvent} is handled in \inlinecode{Horizontal ScrollViewWithPropagation}.

\subsection{Positioning child nodes}
\label{subsec:problem-positioning}
\todo[inline]{\kasia{M., describe positioning nodes.}}