\section{Android application}
\label{sec:android-app}

\subsection{Navigation}
\label{subsec:drawing}
The first step in creating an Android application was writing the basic views. According to the project, our application should consist of two "views" -- the first with list of mind maps and the second, with a view of a single map. Both views share an action bar with action buttons(for example: open a file, close a map, add a new map) and application's name and icon, as well as a navigation bar with tabs. 

\subsubsection{Action Bar}
\label{subsubsec:action-bar}
A basic component of most Android applications is an Action Bar. It is one of the most important design elements due to the fact, that most Android applications share it. Due to this consistency, a potential user is instantly familiar with application's basic interface. 

There is a number of things that can be put inside Action Bar, for example search bar, action buttons etc. In our application we added the following components:
\begin{itemize}
	\item Button for importing an existing mind map  from an XMind file (in a main view with list of available maps)
	\item Button for adding a new mind map (in a main view with list of available maps)
	\item Button for closing an opened mind map (in a single map view)
	\item Navigation bar which consists of tabs with opened maps (default tab is a view with list of available maps)
\end{itemize}

We want our application to be runnable even on older Android version, so instead of regular ActionBar libraries we decided to use support libraries, which take care of backward compatibility from 2.x Android versions.

\inlinecode{ActionBarSherlock} is an standalone library designed to simplify the use of the action bar in all versions of Android through a single API. The library will automatically use the native \inlinecode{ActionBar} implementation on Android 4.0 or later\cite{Wharton:2013:sherlock}. Using it is fairly simple -- the main difference is in \inlinecode{ActionBar} classes' and methods' names -- most of them are prefixed with Sherlock (for example: \inlinecode{SherlockActivity, SherlockFragmentActivity, SherlockFragmen} etc.), the same with imports. 

\subsubsection{Multi-directional ScrollView}
\label{subsubsec:action-bar}
Our application' most important feature -- creating mind maps -- requires a convenient way of navigating through a map. It should support multi-directional scrolling. In Android API there is no class which can handle multi directional scrolling. Some classes, like \inlinecode{TextView} or \inlinecode{ListView} have vertical scrolling implemented, but generally, scrolling is handled by two classes extending \inlinecode{android.widget.FrameLayout} -- \inlinecode{HorizontalScrollView} and \inlinecode{ScrollView}. 

In our application we implemented multi-directional scrolling in a class \inlinecode{Horizontal ScrollViewWithPropagation} which extends \inlinecode{HorizontalScrollView}. Inside, there is a \inlinecode{ScrollView} variable. If this inner \inlinecode{ScrollView} is set, we obtain o copy of \inlinecode{MotionEvent}, then we transform this copy in X axis and dispatch to the inner \inlinecode{ScrollView}. In the end, the original \inlinecode{MotionEvent} is handled in \inlinecode{Horizontal ScrollViewWithPropagation}.

\begin{figure}[h]
	\centering
	\missingfigure{\michal{List view screen}}
	\caption{View of mind map list, initial screen.}
	\label{fig:screen-maplist}
\end{figure}

\subsection{Drawing mind maps}
\label{subsec:drawing}
In the next stage of work we focused on a single mind map view. The main components used in drawing are \inlinecode{NodeView} representing a single mind node and \inlinecode{ArrowView} which serves as a line connecting mind nodes. They are placed in the \inlinecode{MindFragment}. Every \inlinecode{NodeView}  is paired with SubtreeWrapper, which acts as a "container" circumjacent mind node and its children.

\inlinecode{NodeView} is implemented as extending \inlinecode{FrameLayout}. It extends a \inlinecode{ViewGroup}, and we chose it because mind node's view have two children: a text field with node's content and a button. \inlinecode{FrameLayout} can be used as a parent for multiple children and it can control their position within the \inlinecode{ViewGroup} by assigning gravity to each child with the android:layout\_gravity attribute. Child views are drawn in a stack, with the latest added child on top \cite{API:2013:fl}.

Arrow is implemented as a single View. It connects a mind node with its parent. If a mind node has multiple children, then lines coming out of the child nodes are connected in one point and then a single line goes to the parent node. It makes the whole map more readable. 

In order to keep the code readability, we moved he process of drawing to a separate class -- \inlinecode{MapPainter}, whose constructor is called in the \inlinecode{onDrawView} method of the \inlinecode{MapFragment}. This class provides all necessary values and methods needed to draw a mind map:
\begin{itemize}
	\item paper padding and  subtree margin
	\item the horizontal distance between child nodes
	\item \inlinecode{arcShortRadius} which determines the radius depending on the number of children which is used later in map painter to calculate the position of mind node on the X axis
	\item \inlinecode{nodeViewSize} setting the size of a mind node
	\item \inlinecode{initializeNodeV} which initializes inflated mind node layout  
	\item \inlinecode{updateNodeView} setting the content of a mind node
\end{itemize}
 As soon as other elements are prepared --  \inlinecode{HorizontalScrollView} and its inner \inlinecode{ScrollView} layouts are found and set, current mind map is found by uuid and the paper layout is set -- a map painter is called. 

When it comes to the positioning, it was one of the most difficult tasks we faced. \inlinecode{MapPainter} handles calculating the position of mind nodes and arrows. It also manages \inlinecode{SubtreeWrappers} and their accordance with \inlinecode{NodeViews}. It can update the size and coordinates of mind nodes, as well as remove them, or recalculate nodes' positions. 

\subsection{Creating, editing and removing mind nodes}
\label{subsec:drawing}



\begin{figure}[h]
	\centering
	\missingfigure{\michal{Mind map view screen}}
	\caption{View of mind map.}
	\label{fig:screen-map}
\end{figure}

\subsection{Importing from existing .xmind files}
\label{subsec:import}

\begin{figure}[h]
	\centering
	\missingfigure{\kasia{A file chooser screen}}
	\caption{View of file chooser - importing an existing .xmind file.}
	\label{fig:screen-filechooser}
\end{figure}


\subsection{User interface}
\label{subsec:ui}
Thanks to multi-directional scrolling it is easy to navigate even if the map is big.

\todo[inline]{\kasia{Why we designed UI in such a way.}}