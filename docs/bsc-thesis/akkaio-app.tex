\section{Akka.io application}
\label{sec:akka-app}
Akka component was implemented almost entirely according to our project. In order to make it possible to communicate between Android devices and actor system on the server-side there are several REST web services from Spray.io. When more than one user is working on the mind map, each device gets its own actor.  Two-directional communication is implemented by long-polling: a mobile app initiates a connection with a REST service which waits with responding until its actor receives a message from another actor. See \cref{subsec:android-akka-comm} for theoretical details.  

\subsection{Actors system }
\label{subsection:akka-actors}
The actor model is described in \cref{subsection:akka-actors}. "Since Akka enforces parental supervision every actor is supervised and (potentially) the supervisor of its children" \cite{AkkaDoc:2013:Actors}. In order to receive messages, every actor must implement \inlinecode{receive} methods, which describe its behavior. 

In our application we have a number of actors which perform various functions.
\inlinecode{Poller} 
\inlinecode{Updater}
\inlinecode{Service}

\subsubsection{Supervisor actor}
\label{subsubsection:akka-actors-supervisor}
Main supervisor actor is provided by Akka; tightly integrated with the actor system. There is always one such actor for each system.
	
\subsubsection{Per-user actors}
\label{subsubsection:akka-actors-peruser}

\subsection{Database and Squeryl}
\label{subsection:akka-database}

\subsection{Spray and JSON}
\label{subsection:akka-spray}
Spray is an additional layer which enables connection between Akka and application using JSON protocol. 

In our application we added a trait \inlinecode{CustomJsonFormats}, which does necessary modifications in default JSON protocol. 

\subsection{Synchronization}
\label{subsection:akka-synchro}
The synchronization is based on the server time. 
There are two API URLs: 
\begin{verbatim}
private def urlForPoll(since: Long) = s"$baseUrl/poll/since/$since"
private def urlForUpdate = s"$baseUrl/update"
\end{verbatim}
Every node has written its cloudTime (meaning server time). Server does not have to keep the state of the connected devices -- every device checks the highest time of modification and sends a request for update since that time.


\begin{figure}[h]
	\centering
	\missingfigure{\michal{2 devices, collaboration}}
	\caption{View of collaboration.}
	\label{fig:screen-collaboration}
\end{figure}
